<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Survey Visualization</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #0a0a0a;
      color: #a0a0a0;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
      min-height: 100vh;
      padding: 1.5rem;
    }
    h1 { color: #4a7a4a; font-size: 1.1rem; letter-spacing: 0.15em; margin-bottom: 0.3rem; }
    .subtitle { color: #555; font-size: 0.75rem; margin-bottom: 1.5rem; }
    .container { max-width: 1600px; margin: 0 auto; }
    .row { display: flex; gap: 1.5rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .col { flex: 1; min-width: 300px; }
    .col-wide { flex: 2; min-width: 500px; }
    .panel {
      background: #111;
      border: 1px solid #222;
      border-radius: 4px;
      padding: 1rem;
      margin-bottom: 1rem;
    }
    .panel-title {
      color: #666;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 0.75rem;
    }
    button {
      background: #1a1a1a;
      border: 1px solid #333;
      color: #888;
      padding: 0.4rem 0.8rem;
      font-family: inherit;
      font-size: 0.75rem;
      cursor: pointer;
      border-radius: 3px;
      margin-right: 0.3rem;
    }
    button:hover { background: #222; color: #aaa; }
    button.primary { background: #1a2a1a; border-color: #2a4a2a; color: #6a9a6a; }
    button.active { background: #2a4a2a; border-color: #3a6a3a; color: #8aba8a; }

    .chart-container {
      background: #0a0a0a;
      border: 1px solid #1a1a1a;
      border-radius: 3px;
      position: relative;
    }
    canvas { display: block; }

    .controls { display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; margin-bottom: 1rem; }
    .control-group { display: flex; align-items: center; gap: 0.5rem; }
    .control-group label { font-size: 0.7rem; color: #555; }
    .control-group select, .control-group input {
      background: #0d0d0d; border: 1px solid #222; color: #888;
      padding: 0.3rem; font-family: inherit; font-size: 0.7rem;
    }

    .histogram-container { display: flex; gap: 1rem; }
    .histogram { flex: 1; }

    .tooltip {
      position: absolute;
      background: #1a1a1a;
      border: 1px solid #333;
      padding: 0.5rem;
      font-size: 0.7rem;
      pointer-events: none;
      z-index: 100;
      display: none;
      max-width: 200px;
    }

    .legend {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      font-size: 0.7rem;
      margin-top: 0.5rem;
    }
    .legend-item { display: flex; align-items: center; gap: 0.3rem; }
    .legend-color { width: 12px; height: 12px; border-radius: 2px; }

    .preview-panel { display: flex; gap: 1rem; }
    .preview-canvas { border: 1px solid #222; background: #050505; }
    .preview-info { flex: 1; font-size: 0.7rem; }
    .preview-title { font-size: 0.9rem; color: #7a9a7a; margin-bottom: 0.5rem; }
    .preview-metric { display: flex; justify-content: space-between; margin: 0.2rem 0; }
    .preview-label { color: #555; }
    .preview-value { color: #888; }

    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; font-size: 0.7rem; }
    .stat-box { background: #0d0d0d; padding: 0.5rem; border-radius: 2px; text-align: center; }
    .stat-label { color: #555; font-size: 0.6rem; }
    .stat-value { color: #6a9a6a; font-size: 1rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1>SURVEY VISUALIZATION</h1>
    <p class="subtitle">Explore the (λ, D, γ) space of Life-like rules</p>

    <div class="row">
      <div class="col-wide">
        <div class="panel">
          <div class="panel-title">Scatter Plot</div>
          <div class="controls">
            <div class="control-group">
              <label>X axis:</label>
              <select id="x-axis">
                <option value="lambda" selected>λ (Lambda)</option>
                <option value="D">D (Dimension)</option>
                <option value="gamma">γ (Gamma)</option>
                <option value="cluster_count">Clusters</option>
                <option value="edge_ratio">Edge Ratio</option>
                <option value="density_variance">Density Var</option>
                <option value="pop_final">Population</option>
              </select>
            </div>
            <div class="control-group">
              <label>Y axis:</label>
              <select id="y-axis">
                <option value="lambda">λ (Lambda)</option>
                <option value="D" selected>D (Dimension)</option>
                <option value="gamma">γ (Gamma)</option>
                <option value="cluster_count">Clusters</option>
                <option value="edge_ratio">Edge Ratio</option>
                <option value="density_variance">Density Var</option>
                <option value="pop_final">Population</option>
              </select>
            </div>
            <div class="control-group">
              <label>Color:</label>
              <select id="color-by">
                <option value="classification" selected>Classification</option>
                <option value="gamma">γ (Gamma)</option>
                <option value="cluster_count">Clusters</option>
                <option value="edge_ratio">Edge Ratio</option>
              </select>
            </div>
            <div class="control-group">
              <label>Filter:</label>
              <select id="filter-class">
                <option value="all" selected>All</option>
                <option value="aperiodic">Aperiodic</option>
                <option value="periodic">Periodic</option>
                <option value="fixed">Fixed</option>
                <option value="extinct">Extinct</option>
              </select>
            </div>
            <button id="btn-refresh" class="primary">Refresh</button>
          </div>
          <div class="chart-container">
            <canvas id="scatter-canvas" width="800" height="500"></canvas>
            <div class="tooltip" id="scatter-tooltip"></div>
          </div>
          <div class="legend" id="scatter-legend"></div>
        </div>
      </div>

      <div class="col">
        <div class="panel">
          <div class="panel-title">Load Data</div>
          <input type="file" id="file-input" accept=".csv" style="margin-bottom: 0.5rem; font-size: 0.75rem;">
          <button id="btn-load-v1">Load v1</button>
          <button id="btn-load-v2">Load v2</button>
          <div id="load-status" style="margin-top: 0.5rem; font-size: 0.7rem; color: #555;"></div>
        </div>

        <div class="panel">
          <div class="panel-title">Statistics</div>
          <div class="stats-grid">
            <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value" id="stat-total">0</div></div>
            <div class="stat-box"><div class="stat-label">Aperiodic</div><div class="stat-value" id="stat-aperiodic">0</div></div>
            <div class="stat-box"><div class="stat-label">Periodic</div><div class="stat-value" id="stat-periodic">0</div></div>
            <div class="stat-box"><div class="stat-label">Fixed</div><div class="stat-value" id="stat-fixed">0</div></div>
          </div>
          <div class="stats-grid" style="margin-top: 0.5rem;">
            <div class="stat-box"><div class="stat-label">Avg λ</div><div class="stat-value" id="stat-lambda">--</div></div>
            <div class="stat-box"><div class="stat-label">Avg D</div><div class="stat-value" id="stat-d">--</div></div>
            <div class="stat-box"><div class="stat-label">Avg γ</div><div class="stat-value" id="stat-gamma">--</div></div>
            <div class="stat-box"><div class="stat-label">Extinct</div><div class="stat-value" id="stat-extinct">0</div></div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Selected Rule</div>
          <div class="preview-panel">
            <canvas id="preview-canvas" class="preview-canvas" width="120" height="120"></canvas>
            <div class="preview-info">
              <div class="preview-title" id="preview-title">Click a point</div>
              <div class="preview-metric"><span class="preview-label">ID:</span><span class="preview-value" id="preview-id">--</span></div>
              <div class="preview-metric"><span class="preview-label">λ:</span><span class="preview-value" id="preview-lambda">--</span></div>
              <div class="preview-metric"><span class="preview-label">D:</span><span class="preview-value" id="preview-d">--</span></div>
              <div class="preview-metric"><span class="preview-label">γ:</span><span class="preview-value" id="preview-gamma">--</span></div>
              <div class="preview-metric"><span class="preview-label">Class:</span><span class="preview-value" id="preview-class">--</span></div>
              <div class="preview-metric"><span class="preview-label">Clusters:</span><span class="preview-value" id="preview-clusters">--</span></div>
              <div class="preview-metric"><span class="preview-label">Edge:</span><span class="preview-value" id="preview-edge">--</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col">
        <div class="panel">
          <div class="panel-title">λ Distribution</div>
          <canvas id="hist-lambda" width="400" height="150"></canvas>
        </div>
      </div>
      <div class="col">
        <div class="panel">
          <div class="panel-title">D Distribution</div>
          <canvas id="hist-d" width="400" height="150"></canvas>
        </div>
      </div>
      <div class="col">
        <div class="panel">
          <div class="panel-title">γ Distribution</div>
          <canvas id="hist-gamma" width="400" height="150"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    // CA Engine for preview
    function seededRandom(seed) {
      return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    class Grid {
      constructor(rows, cols) {
        this.rows = rows; this.cols = cols;
        this.cells = new Uint8Array(rows * cols);
      }
      idx(r, c) { return r * this.cols + c; }
      get(r, c) {
        r = ((r % this.rows) + this.rows) % this.rows;
        c = ((c % this.cols) + this.cols) % this.cols;
        return this.cells[this.idx(r, c)];
      }
      countNeighbors(r, c) {
        let count = 0;
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            if (this.get(r + dr, c + dc) > 0) count++;
          }
        }
        return count;
      }
      randomize(density, seed) {
        const rng = seededRandom(seed);
        for (let i = 0; i < this.cells.length; i++) {
          this.cells[i] = rng() < density ? 1 : 0;
        }
      }
    }

    class Rule {
      constructor(birthMask, survivalMask) {
        this.birthMask = birthMask;
        this.survivalMask = survivalMask;
      }
      shouldBirth(n) { return (this.birthMask & (1 << n)) !== 0; }
      shouldSurvive(n) { return (this.survivalMask & (1 << n)) !== 0; }
      static fromId(id) { return new Rule(Math.floor(id / 512), id % 512); }
    }

    function stepInPlace(current, next, rule) {
      for (let r = 0; r < current.rows; r++) {
        for (let c = 0; c < current.cols; c++) {
          const state = current.get(r, c);
          const n = current.countNeighbors(r, c);
          next.cells[next.idx(r, c)] = state > 0 ? (rule.shouldSurvive(n) ? 1 : 0) : (rule.shouldBirth(n) ? 1 : 0);
        }
      }
    }

    // State
    let data = [];
    let filteredData = [];
    let selectedRule = null;

    const classColors = {
      aperiodic: '#4a7a4a',
      periodic: '#7a7a4a',
      fixed: '#4a7a7a',
      extinct: '#4a4a4a'
    };

    // DOM
    const scatterCanvas = document.getElementById('scatter-canvas');
    const scatterCtx = scatterCanvas.getContext('2d');
    const tooltip = document.getElementById('scatter-tooltip');
    const previewCanvas = document.getElementById('preview-canvas');
    const previewCtx = previewCanvas.getContext('2d');

    function parseCSV(text) {
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.replace(/"/g, ''));
      const result = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].match(/(".*?"|[^,]+)/g) || [];
        const row = {};
        headers.forEach((h, j) => {
          let v = (values[j] || '').replace(/^"|"$/g, '');
          row[h] = isNaN(v) || v === '' ? v : parseFloat(v);
        });
        result.push(row);
      }
      return result;
    }

    function loadFromStorage(key) {
      try {
        const stored = JSON.parse(localStorage.getItem(key));
        if (stored && stored.results) {
          data = stored.results;
          updateAll();
          document.getElementById('load-status').textContent = `Loaded ${data.length} rules from ${key}`;
        }
      } catch (e) {
        document.getElementById('load-status').textContent = 'Error: ' + e.message;
      }
    }

    function updateAll() {
      applyFilter();
      updateStats();
      drawScatter();
      drawHistograms();
    }

    function applyFilter() {
      const classFilter = document.getElementById('filter-class').value;
      filteredData = data.filter(r => {
        if (classFilter !== 'all' && r.classification !== classFilter) return false;
        return true;
      });
    }

    function updateStats() {
      const counts = { aperiodic: 0, periodic: 0, fixed: 0, extinct: 0 };
      let sumL = 0, countL = 0, sumD = 0, sumG = 0;

      for (const r of data) {
        counts[r.classification]++;
        if (r.lambda > -10) { sumL += r.lambda; countL++; }
        sumD += r.D;
        sumG += r.gamma;
      }

      document.getElementById('stat-total').textContent = data.length;
      document.getElementById('stat-aperiodic').textContent = counts.aperiodic;
      document.getElementById('stat-periodic').textContent = counts.periodic;
      document.getElementById('stat-fixed').textContent = counts.fixed;
      document.getElementById('stat-extinct').textContent = counts.extinct;
      document.getElementById('stat-lambda').textContent = countL > 0 ? (sumL / countL).toFixed(3) : '--';
      document.getElementById('stat-d').textContent = data.length > 0 ? (sumD / data.length).toFixed(3) : '--';
      document.getElementById('stat-gamma').textContent = data.length > 0 ? (sumG / data.length).toFixed(0) : '--';
    }

    function drawScatter() {
      const xKey = document.getElementById('x-axis').value;
      const yKey = document.getElementById('y-axis').value;
      const colorBy = document.getElementById('color-by').value;

      const w = scatterCanvas.width;
      const h = scatterCanvas.height;
      const margin = { top: 20, right: 20, bottom: 40, left: 50 };
      const plotW = w - margin.left - margin.right;
      const plotH = h - margin.top - margin.bottom;

      scatterCtx.fillStyle = '#0a0a0a';
      scatterCtx.fillRect(0, 0, w, h);

      if (filteredData.length === 0) return;

      // Get ranges (filter outliers for better viz)
      const xVals = filteredData.map(r => r[xKey]).filter(v => v !== undefined && v > -10);
      const yVals = filteredData.map(r => r[yKey]).filter(v => v !== undefined && v > -10);

      const xMin = Math.min(...xVals);
      const xMax = Math.max(...xVals);
      const yMin = Math.min(...yVals);
      const yMax = Math.max(...yVals);

      const xRange = xMax - xMin || 1;
      const yRange = yMax - yMin || 1;

      // Draw axes
      scatterCtx.strokeStyle = '#333';
      scatterCtx.lineWidth = 1;
      scatterCtx.beginPath();
      scatterCtx.moveTo(margin.left, margin.top);
      scatterCtx.lineTo(margin.left, h - margin.bottom);
      scatterCtx.lineTo(w - margin.right, h - margin.bottom);
      scatterCtx.stroke();

      // Labels
      scatterCtx.fillStyle = '#555';
      scatterCtx.font = '10px monospace';
      scatterCtx.textAlign = 'center';
      scatterCtx.fillText(xKey, w / 2, h - 10);
      scatterCtx.save();
      scatterCtx.translate(15, h / 2);
      scatterCtx.rotate(-Math.PI / 2);
      scatterCtx.fillText(yKey, 0, 0);
      scatterCtx.restore();

      // Axis values
      scatterCtx.fillStyle = '#444';
      scatterCtx.textAlign = 'center';
      scatterCtx.fillText(xMin.toFixed(2), margin.left, h - margin.bottom + 15);
      scatterCtx.fillText(xMax.toFixed(2), w - margin.right, h - margin.bottom + 15);
      scatterCtx.textAlign = 'right';
      scatterCtx.fillText(yMin.toFixed(2), margin.left - 5, h - margin.bottom);
      scatterCtx.fillText(yMax.toFixed(2), margin.left - 5, margin.top + 10);

      // Color scale for continuous
      let colorScale;
      if (colorBy === 'classification') {
        colorScale = r => classColors[r.classification] || '#444';
      } else {
        const cVals = filteredData.map(r => r[colorBy]).filter(v => v !== undefined);
        const cMin = Math.min(...cVals);
        const cMax = Math.max(...cVals);
        const cRange = cMax - cMin || 1;
        colorScale = r => {
          const t = (r[colorBy] - cMin) / cRange;
          const g = Math.floor(50 + t * 150);
          return `rgb(${Math.floor(50 + (1-t)*100)}, ${g}, ${Math.floor(50 + t*100)})`;
        };
      }

      // Draw points
      for (const r of filteredData) {
        const x = r[xKey];
        const y = r[yKey];
        if (x === undefined || y === undefined || x < -10 || y < -10) continue;

        const px = margin.left + ((x - xMin) / xRange) * plotW;
        const py = h - margin.bottom - ((y - yMin) / yRange) * plotH;

        scatterCtx.fillStyle = colorScale(r);
        scatterCtx.beginPath();
        scatterCtx.arc(px, py, 2, 0, Math.PI * 2);
        scatterCtx.fill();
      }

      // Update legend
      const legend = document.getElementById('scatter-legend');
      if (colorBy === 'classification') {
        legend.innerHTML = Object.entries(classColors).map(([cls, color]) =>
          `<div class="legend-item"><div class="legend-color" style="background:${color}"></div>${cls}</div>`
        ).join('');
      } else {
        legend.innerHTML = `<div class="legend-item">Color: ${colorBy} (low → high)</div>`;
      }

      // Store for click detection
      scatterCanvas._plotData = { xKey, yKey, xMin, xRange, yMin, yRange, margin, plotW, plotH };
    }

    function drawHistograms() {
      drawHistogram('hist-lambda', 'lambda', filteredData);
      drawHistogram('hist-d', 'D', filteredData);
      drawHistogram('hist-gamma', 'gamma', filteredData);
    }

    function drawHistogram(canvasId, key, data) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;

      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, w, h);

      const vals = data.map(r => r[key]).filter(v => v !== undefined && v > -10);
      if (vals.length === 0) return;

      const min = Math.min(...vals);
      const max = Math.max(...vals);
      const range = max - min || 1;
      const numBins = 50;
      const bins = new Array(numBins).fill(0);

      for (const v of vals) {
        const bin = Math.min(numBins - 1, Math.floor(((v - min) / range) * numBins));
        bins[bin]++;
      }

      const maxCount = Math.max(...bins);
      const barW = (w - 40) / numBins;

      ctx.fillStyle = '#4a7a4a';
      for (let i = 0; i < numBins; i++) {
        const barH = (bins[i] / maxCount) * (h - 30);
        ctx.fillRect(30 + i * barW, h - 20 - barH, barW - 1, barH);
      }

      // Axis labels
      ctx.fillStyle = '#444';
      ctx.font = '9px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(min.toFixed(2), 30, h - 5);
      ctx.textAlign = 'right';
      ctx.fillText(max.toFixed(2), w - 10, h - 5);
    }

    function drawPreview(ruleId) {
      const rule = Rule.fromId(ruleId);
      const size = 40;
      const cellSize = 3;

      previewCtx.fillStyle = '#050505';
      previewCtx.fillRect(0, 0, 120, 120);

      const grid = new Grid(size, size);
      grid.randomize(0.3, ruleId * 7919);
      let current = grid;
      let next = new Grid(size, size);

      for (let i = 0; i < 150; i++) {
        stepInPlace(current, next, rule);
        [current, next] = [next, current];
      }

      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (current.cells[current.idx(r, c)] > 0) {
            previewCtx.fillStyle = '#4a7a4a';
            previewCtx.fillRect(c * cellSize, r * cellSize, cellSize - 1, cellSize - 1);
          }
        }
      }
    }

    function selectRule(rule) {
      selectedRule = rule;
      document.getElementById('preview-title').textContent = rule.rule_string;
      document.getElementById('preview-id').textContent = rule.rule_id;
      document.getElementById('preview-lambda').textContent = rule.lambda > -10 ? rule.lambda.toFixed(4) : 'healed';
      document.getElementById('preview-d').textContent = rule.D.toFixed(4);
      document.getElementById('preview-gamma').textContent = rule.gamma.toFixed(2);
      document.getElementById('preview-class').textContent = rule.classification;
      document.getElementById('preview-clusters').textContent = rule.cluster_count || '--';
      document.getElementById('preview-edge').textContent = rule.edge_ratio ? rule.edge_ratio.toFixed(3) : '--';
      drawPreview(rule.rule_id);
    }

    // Event handlers
    document.getElementById('file-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        data = parseCSV(ev.target.result);
        updateAll();
        document.getElementById('load-status').textContent = `Loaded ${data.length} rules from ${file.name}`;
      };
      reader.readAsText(file);
    });

    document.getElementById('btn-load-v1').addEventListener('click', () => loadFromStorage('cells_survey_v2'));
    document.getElementById('btn-load-v2').addEventListener('click', () => loadFromStorage('cells_survey_v3'));
    document.getElementById('btn-refresh').addEventListener('click', updateAll);

    ['x-axis', 'y-axis', 'color-by', 'filter-class'].forEach(id => {
      document.getElementById(id).addEventListener('change', updateAll);
    });

    scatterCanvas.addEventListener('mousemove', (e) => {
      if (!scatterCanvas._plotData || filteredData.length === 0) return;
      const { xKey, yKey, xMin, xRange, yMin, yRange, margin, plotW, plotH } = scatterCanvas._plotData;
      const rect = scatterCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      // Find closest point
      let closest = null;
      let minDist = 20;

      for (const r of filteredData) {
        const x = r[xKey];
        const y = r[yKey];
        if (x === undefined || y === undefined || x < -10 || y < -10) continue;

        const px = margin.left + ((x - xMin) / xRange) * plotW;
        const py = scatterCanvas.height - margin.bottom - ((y - yMin) / yRange) * plotH;
        const dist = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);

        if (dist < minDist) {
          minDist = dist;
          closest = r;
        }
      }

      if (closest) {
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
        tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
        tooltip.innerHTML = `<strong>${closest.rule_string}</strong><br>λ=${closest.lambda > -10 ? closest.lambda.toFixed(3) : 'heal'} D=${closest.D.toFixed(2)} γ=${closest.gamma.toFixed(0)}`;
      } else {
        tooltip.style.display = 'none';
      }
    });

    scatterCanvas.addEventListener('click', (e) => {
      if (!scatterCanvas._plotData || filteredData.length === 0) return;
      const { xKey, yKey, xMin, xRange, yMin, yRange, margin, plotW, plotH } = scatterCanvas._plotData;
      const rect = scatterCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      let closest = null;
      let minDist = 20;

      for (const r of filteredData) {
        const x = r[xKey];
        const y = r[yKey];
        if (x === undefined || y === undefined || x < -10 || y < -10) continue;

        const px = margin.left + ((x - xMin) / xRange) * plotW;
        const py = scatterCanvas.height - margin.bottom - ((y - yMin) / yRange) * plotH;
        const dist = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);

        if (dist < minDist) {
          minDist = dist;
          closest = r;
        }
      }

      if (closest) {
        selectRule(closest);
      }
    });

    scatterCanvas.addEventListener('mouseleave', () => {
      tooltip.style.display = 'none';
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cells - Pass 2 Analysis</title>
  <link rel="stylesheet" href="shared/styles.css">
  <script src="shared/nav.js"></script>
  <style>
    body { padding: 1.5rem; padding-top: 4.5rem; }
    h1 { color: #4a7a4a; font-size: 1.2rem; letter-spacing: 0.15em; margin-bottom: 0.5rem; }
    .subtitle { color: #555; font-size: 0.75rem; margin-bottom: 1.5rem; }
    .gpu-badge { display: inline-block; background: #1a2a1a; color: #6a9a6a; padding: 0.2rem 0.5rem; border-radius: 3px; font-size: 0.65rem; margin-left: 0.75rem; }
    .container { max-width: 1600px; margin: 0 auto; }
    .main-grid { display: grid; grid-template-columns: 1fr 380px; gap: 1.5rem; }
    @media (max-width: 1000px) { .main-grid { grid-template-columns: 1fr; } }

    .panel { background: #111; border: 1px solid #222; border-radius: 4px; padding: 1.25rem; margin-bottom: 1rem; }
    .panel-title { color: #666; font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.15em; margin-bottom: 0.75rem; }

    button { background: #1a1a1a; border: 1px solid #333; color: #888; padding: 0.5rem 1rem; font-family: inherit; font-size: 0.75rem; cursor: pointer; border-radius: 3px; margin-right: 0.4rem; margin-bottom: 0.4rem; }
    button:hover { background: #222; color: #aaa; }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    button.primary { background: #1a2a1a; border-color: #2a4a2a; color: #6a9a6a; }

    .progress-bar { height: 20px; background: #1a1a1a; border-radius: 3px; overflow: hidden; position: relative; margin: 0.75rem 0; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #2a4a2a, #3a6a3a); transition: width 0.3s ease; }
    .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.7rem; color: #888; }

    .filter-panel { background: #0d0d0d; padding: 1rem; border-radius: 3px; margin-bottom: 1rem; }
    .filter-row { display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; margin-bottom: 0.5rem; }
    .filter-item { display: flex; align-items: center; gap: 0.5rem; }
    .filter-item label { font-size: 0.7rem; color: #555; }
    .filter-item input, .filter-item select { background: #111; border: 1px solid #222; color: #888; padding: 0.3rem 0.5rem; font-family: inherit; font-size: 0.75rem; }
    .filter-item input { width: 70px; }
    .filter-count { font-size: 0.8rem; color: #6a9a6a; }

    .results-table { width: 100%; border-collapse: collapse; font-size: 0.7rem; }
    .results-table th { text-align: left; padding: 0.4rem; border-bottom: 1px solid #333; color: #555; font-weight: normal; font-size: 0.6rem; cursor: pointer; }
    .results-table th:hover { color: #888; }
    .results-table td { padding: 0.4rem; border-bottom: 1px solid #1a1a1a; }
    .results-table tr:hover { background: #151515; cursor: pointer; }
    .results-table tr.selected { background: #1a2a1a; }
    .results-scroll { max-height: 350px; overflow-y: auto; }

    .preview-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; }
    .preview-item { text-align: center; }
    .preview-item canvas { border: 1px solid #222; background: #050505; width: 80px; height: 80px; image-rendering: pixelated; }
    .preview-label { font-size: 0.6rem; color: #555; margin-top: 0.2rem; }

    .metric-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.4rem; font-size: 0.7rem; }
    .metric-item { background: #0d0d0d; padding: 0.4rem 0.5rem; border-radius: 2px; }
    .metric-label { color: #555; font-size: 0.6rem; }
    .metric-value { color: #6a9a6a; }

    .chart-container { height: 80px; background: #0d0d0d; border-radius: 3px; position: relative; margin-top: 0.5rem; }
    .chart-container canvas { width: 100%; height: 100%; }

    .log { background: #0d0d0d; border: 1px solid #1a1a1a; border-radius: 3px; padding: 0.5rem; max-height: 100px; overflow-y: auto; font-size: 0.65rem; }
    .log-entry { margin: 0.1rem 0; color: #555; }
    .log-entry.success { color: #5a8a5a; }
    .log-entry.error { color: #8a5a5a; }
  </style>
</head>
<body>
  <div class="container">
    <h1>PASS 2 - DEEP ANALYSIS <span class="gpu-badge">GPU</span></h1>
    <p class="subtitle">10-trial λ, γ trajectory, spatial autocorrelation, snapshots - GPU accelerated</p>

    <div class="main-grid">
      <div class="left-col">
        <div class="panel">
          <div class="panel-title">Load Pass 1 Data</div>
          <input type="file" id="file-input" accept=".csv" style="margin-bottom: 0.75rem; font-size: 0.75rem;">
          <button id="btn-load-localstorage">Load from localStorage</button>
          <div id="load-status" style="margin-top: 0.5rem; font-size: 0.7rem; color: #555;"></div>
        </div>

        <div class="panel">
          <div class="panel-title">Filter Criteria</div>
          <div class="filter-panel">
            <div class="filter-row">
              <div class="filter-item">
                <label>Class:</label>
                <select id="filter-class">
                  <option value="all">All</option>
                  <option value="aperiodic" selected>Aperiodic</option>
                  <option value="periodic">Periodic</option>
                </select>
              </div>
              <div class="filter-item">
                <label>λ max:</label>
                <input type="number" id="filter-lambda-max" value="0.05" step="0.01">
              </div>
              <div class="filter-item">
                <label>Pop min:</label>
                <input type="number" id="filter-pop-min" value="100" step="50">
              </div>
              <div class="filter-item">
                <label>Exclude B0:</label>
                <input type="checkbox" id="filter-no-b0" checked>
              </div>
            </div>
            <div class="filter-row">
              <button id="btn-apply-filter" class="primary">Apply Filter</button>
              <span class="filter-count" id="filter-count">0 rules match</span>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Filtered Rules</div>
          <div class="results-scroll">
            <table class="results-table">
              <thead><tr>
                <th data-sort="rule_id">ID</th>
                <th data-sort="rule_string">Rule</th>
                <th data-sort="lambda">λ</th>
                <th data-sort="D">D</th>
                <th data-sort="period">Per</th>
                <th data-sort="pop_final">Pop</th>
                <th data-sort="classification">Class</th>
              </tr></thead>
              <tbody id="results-body"><tr><td colspan="7" style="text-align:center;color:#444">Load Pass 1 data first</td></tr></tbody>
            </table>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Pass 2 Analysis</div>
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            <div class="progress-text" id="progress-text">0 / 0</div>
          </div>
          <button id="btn-run-pass2" class="primary" disabled>Run Pass 2 (GPU)</button>
          <button id="btn-stop" disabled>Stop</button>
          <button id="btn-download" disabled>Download CSV</button>
          <div id="gpu-status" style="margin-top: 0.5rem; font-size: 0.7rem; color: #555;"></div>
        </div>

        <div class="panel">
          <div class="panel-title">Log</div>
          <div class="log" id="log"></div>
        </div>
      </div>

      <div class="right-col">
        <div class="panel">
          <div class="panel-title">Selected Rule</div>
          <div id="selected-rule-name" style="font-size: 1.1rem; color: #7a9a7a; margin-bottom: 0.75rem;">--</div>

          <div class="preview-grid">
            <div class="preview-item">
              <canvas id="preview-t100" width="64" height="64"></canvas>
              <div class="preview-label">t=100</div>
            </div>
            <div class="preview-item">
              <canvas id="preview-t500" width="64" height="64"></canvas>
              <div class="preview-label">t=500</div>
            </div>
            <div class="preview-item">
              <canvas id="preview-t1000" width="64" height="64"></canvas>
              <div class="preview-label">t=1000</div>
            </div>
            <div class="preview-item">
              <canvas id="preview-final" width="64" height="64"></canvas>
              <div class="preview-label">Final</div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Pass 1 Metrics</div>
          <div class="metric-grid" id="pass1-metrics">
            <div class="metric-item"><div class="metric-label">λ</div><div class="metric-value">--</div></div>
            <div class="metric-item"><div class="metric-label">D</div><div class="metric-value">--</div></div>
            <div class="metric-item"><div class="metric-label">Period</div><div class="metric-value">--</div></div>
            <div class="metric-item"><div class="metric-label">Pop</div><div class="metric-value">--</div></div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Pass 2 Metrics</div>
          <div class="metric-grid" id="pass2-metrics">
            <div class="metric-item"><div class="metric-label">λ (10-trial)</div><div class="metric-value" id="m-lambda10">--</div></div>
            <div class="metric-item"><div class="metric-label">λ std</div><div class="metric-value" id="m-lambda10-std">--</div></div>
            <div class="metric-item"><div class="metric-label">Autocorr</div><div class="metric-value" id="m-autocorr">--</div></div>
            <div class="metric-item"><div class="metric-label">Symmetry</div><div class="metric-value" id="m-symmetry">--</div></div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Population Trajectory</div>
          <div class="chart-container">
            <canvas id="pop-chart"></canvas>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Activity Trajectory</div>
          <div class="chart-container">
            <canvas id="activity-chart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // STATE
    // ============================================
    let pass1Data = [];
    let filteredData = [];
    let pass2Results = new Map();
    let selectedRuleId = null;
    let isRunning = false;
    let gpuDevice = null;
    let gpuAvailable = false;

    const logEl = document.getElementById('log');

    function log(msg, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
      if (logEl.children.length > 50) logEl.removeChild(logEl.firstChild);
    }

    // ============================================
    // WEBGPU SETUP
    // ============================================
    const caShaderCode = `
      struct Uniforms {
        size: u32,
        birthMask: u32,
        survivalMask: u32,
        step: u32,
      }

      struct Counters {
        population: atomic<u32>,
        changes: atomic<u32>,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read> gridIn: array<u32>;
      @group(0) @binding(2) var<storage, read_write> gridOut: array<u32>;
      @group(0) @binding(3) var<storage, read_write> counters: Counters;

      @compute @workgroup_size(16, 16)
      fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
        let size = uniforms.size;
        if (gid.x >= size || gid.y >= size) { return; }

        var neighbors: u32 = 0;
        for (var dy: i32 = -1; dy <= 1; dy++) {
          for (var dx: i32 = -1; dx <= 1; dx++) {
            if (dx == 0 && dy == 0) { continue; }
            let nx = (i32(gid.x) + dx + i32(size)) % i32(size);
            let ny = (i32(gid.y) + dy + i32(size)) % i32(size);
            if (gridIn[u32(ny) * size + u32(nx)] > 0u) { neighbors++; }
          }
        }

        let idx = gid.y * size + gid.x;
        let wasAlive = gridIn[idx] > 0u;
        var isAlive: bool = false;
        if (wasAlive) {
          isAlive = (uniforms.survivalMask & (1u << neighbors)) != 0u;
        } else {
          isAlive = (uniforms.birthMask & (1u << neighbors)) != 0u;
        }

        gridOut[idx] = select(0u, 1u, isAlive);

        if (isAlive) { atomicAdd(&counters.population, 1u); }
        if (wasAlive != isAlive) { atomicAdd(&counters.changes, 1u); }
      }
    `;

    // Hamming distance shader for λ measurement
    const hammingShaderCode = `
      struct Counters {
        distance: atomic<u32>,
      }

      @group(0) @binding(0) var<storage, read> gridA: array<u32>;
      @group(0) @binding(1) var<storage, read> gridB: array<u32>;
      @group(0) @binding(2) var<storage, read_write> counters: Counters;

      @compute @workgroup_size(256)
      fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
        let idx = gid.x;
        if (idx >= arrayLength(&gridA)) { return; }
        if (gridA[idx] != gridB[idx]) {
          atomicAdd(&counters.distance, 1u);
        }
      }
    `;

    // Spatial autocorrelation shader
    const autocorrShaderCode = `
      struct Uniforms {
        size: u32,
        population: u32,
        pad1: u32,
        pad2: u32,
      }

      struct Counters {
        sum: atomic<i32>,
        count: atomic<u32>,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read> grid: array<u32>;
      @group(0) @binding(2) var<storage, read_write> counters: Counters;

      @compute @workgroup_size(16, 16)
      fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
        let size = uniforms.size;
        if (gid.x >= size || gid.y >= size) { return; }

        let idx = gid.y * size + gid.x;
        let v1 = i32(grid[idx]);

        // Right neighbor
        let rx = (gid.x + 1u) % size;
        let ridx = gid.y * size + rx;
        let v2r = i32(grid[ridx]);

        // Down neighbor
        let dy = (gid.y + 1u) % size;
        let didx = dy * size + gid.x;
        let v2d = i32(grid[didx]);

        // Accumulate correlation (will normalize on CPU)
        atomicAdd(&counters.sum, v1 * v2r + v1 * v2d);
        atomicAdd(&counters.count, 2u);
      }
    `;

    let caPipeline = null;
    let hammingPipeline = null;
    let autocorrPipeline = null;

    async function initWebGPU() {
      if (!navigator.gpu) {
        document.getElementById('gpu-status').textContent = 'WebGPU not supported';
        log('WebGPU not supported', 'error');
        return false;
      }

      try {
        const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
        if (!adapter) {
          document.getElementById('gpu-status').textContent = 'No GPU adapter';
          return false;
        }

        gpuDevice = await adapter.requestDevice();

        // Create pipelines
        const caModule = gpuDevice.createShaderModule({ code: caShaderCode });
        caPipeline = gpuDevice.createComputePipeline({
          layout: 'auto',
          compute: { module: caModule, entryPoint: 'main' }
        });

        const hammingModule = gpuDevice.createShaderModule({ code: hammingShaderCode });
        hammingPipeline = gpuDevice.createComputePipeline({
          layout: 'auto',
          compute: { module: hammingModule, entryPoint: 'main' }
        });

        const autocorrModule = gpuDevice.createShaderModule({ code: autocorrShaderCode });
        autocorrPipeline = gpuDevice.createComputePipeline({
          layout: 'auto',
          compute: { module: autocorrModule, entryPoint: 'main' }
        });

        gpuAvailable = true;
        document.getElementById('gpu-status').textContent = 'GPU ready';
        log('WebGPU initialized', 'success');
        return true;
      } catch (e) {
        document.getElementById('gpu-status').textContent = 'GPU init failed: ' + e.message;
        log('WebGPU init failed: ' + e.message, 'error');
        return false;
      }
    }

    // ============================================
    // GPU-ACCELERATED ANALYSIS
    // ============================================
    function seededRandom(seed) {
      return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function createInitialGrid(size, density, seed) {
      const rng = seededRandom(seed);
      const data = new Uint32Array(size * size);
      for (let i = 0; i < data.length; i++) {
        data[i] = rng() < density ? 1 : 0;
      }
      return data;
    }

    async function runGPUAnalysis(ruleId, size = 128, steps = 2000) {
      const birthMask = Math.floor(ruleId / 512);
      const survivalMask = ruleId % 512;
      const seed = ruleId * 7919;

      // Create buffers
      const gridSize = size * size * 4;
      const gridBufferA = gpuDevice.createBuffer({ size: gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
      const gridBufferB = gpuDevice.createBuffer({ size: gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
      const uniformBuffer = gpuDevice.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
      const counterBuffer = gpuDevice.createBuffer({ size: 8, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
      const readBuffer = gpuDevice.createBuffer({ size: Math.max(gridSize, 16), usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });

      // Initialize grid
      const initialGrid = createInitialGrid(size, 0.3, seed);
      gpuDevice.queue.writeBuffer(gridBufferA, 0, initialGrid);

      // Create bind groups
      const workgroups = Math.ceil(size / 16);
      const bindGroupA = gpuDevice.createBindGroup({
        layout: caPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: uniformBuffer } },
          { binding: 1, resource: { buffer: gridBufferA } },
          { binding: 2, resource: { buffer: gridBufferB } },
          { binding: 3, resource: { buffer: counterBuffer } },
        ],
      });
      const bindGroupB = gpuDevice.createBindGroup({
        layout: caPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: uniformBuffer } },
          { binding: 1, resource: { buffer: gridBufferB } },
          { binding: 2, resource: { buffer: gridBufferA } },
          { binding: 3, resource: { buffer: counterBuffer } },
        ],
      });

      const snapshots = {};
      const popTrajectory = [];
      const activityTrajectory = [];
      let currentBuffer = 0;

      // Run simulation with snapshots
      const snapshotSteps = [100, 500, 1000, steps];

      for (let step = 0; step <= steps; step++) {
        gpuDevice.queue.writeBuffer(counterBuffer, 0, new Uint32Array([0, 0]));
        gpuDevice.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([size, birthMask, survivalMask, step]));

        const encoder = gpuDevice.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.setPipeline(caPipeline);
        pass.setBindGroup(0, currentBuffer === 0 ? bindGroupA : bindGroupB);
        pass.dispatchWorkgroups(workgroups, workgroups);
        pass.end();
        encoder.copyBufferToBuffer(counterBuffer, 0, readBuffer, 0, 8);
        gpuDevice.queue.submit([encoder.finish()]);

        currentBuffer = 1 - currentBuffer;

        // Read stats every 50 steps
        if (step % 50 === 0 || snapshotSteps.includes(step)) {
          await readBuffer.mapAsync(GPUMapMode.READ);
          const stats = new Uint32Array(readBuffer.getMappedRange().slice(0, 8));
          readBuffer.unmap();

          popTrajectory.push({ t: step, pop: stats[0] });
          activityTrajectory.push({ t: step, activity: stats[1] });

          // Capture snapshot
          if (snapshotSteps.includes(step)) {
            const srcBuffer = currentBuffer === 0 ? gridBufferA : gridBufferB;
            const copyEncoder = gpuDevice.createCommandEncoder();
            copyEncoder.copyBufferToBuffer(srcBuffer, 0, readBuffer, 0, gridSize);
            gpuDevice.queue.submit([copyEncoder.finish()]);

            await readBuffer.mapAsync(GPUMapMode.READ);
            const gridData = new Uint32Array(readBuffer.getMappedRange().slice(0, gridSize));
            readBuffer.unmap();

            snapshots[`t${step}`] = downsampleGrid(gridData, size, 64);
          }

          // Early exit if extinct
          if (stats[0] === 0) break;
        }
      }

      // Measure 10-trial lambda
      const lambda10 = await measureLambda10GPU(ruleId, size, 300, seed);

      // Measure spatial autocorrelation on final state
      const finalBuffer = currentBuffer === 0 ? gridBufferA : gridBufferB;
      const autocorr = await measureAutocorrGPU(finalBuffer, size, popTrajectory[popTrajectory.length - 1]?.pop || 0);

      // Measure symmetry (CPU, it's fast)
      const copyEncoder = gpuDevice.createCommandEncoder();
      copyEncoder.copyBufferToBuffer(finalBuffer, 0, readBuffer, 0, gridSize);
      gpuDevice.queue.submit([copyEncoder.finish()]);
      await readBuffer.mapAsync(GPUMapMode.READ);
      const finalGrid = new Uint32Array(readBuffer.getMappedRange().slice(0, gridSize));
      readBuffer.unmap();
      const symmetry = measureSymmetry(finalGrid, size);

      // Cleanup
      gridBufferA.destroy();
      gridBufferB.destroy();
      uniformBuffer.destroy();
      counterBuffer.destroy();
      readBuffer.destroy();

      return {
        rule_id: ruleId,
        rule_string: ruleIdToString(ruleId),
        lambda_10: lambda10.mean,
        lambda_10_std: lambda10.std,
        spatial_autocorr: autocorr,
        symmetry_h: symmetry.h,
        symmetry_v: symmetry.v,
        pop_trajectory: popTrajectory,
        activity_trajectory: activityTrajectory,
        snapshots
      };
    }

    async function measureLambda10GPU(ruleId, size, steps, baseSeed) {
      const birthMask = Math.floor(ruleId / 512);
      const survivalMask = ruleId % 512;
      const lambdas = [];

      for (let trial = 0; trial < 10; trial++) {
        const seed = baseSeed + trial * 1000000;

        // Create two grids: original and perturbed
        const gridA = createInitialGrid(size, 0.3, seed);
        const gridB = new Uint32Array(gridA);

        // Flip one random cell
        const rng = seededRandom(seed + 999);
        const flipIdx = Math.floor(rng() * size * size);
        gridB[flipIdx] = gridB[flipIdx] ? 0 : 1;

        // Create buffers
        const gridSize = size * size * 4;
        const bufferA1 = gpuDevice.createBuffer({ size: gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
        const bufferA2 = gpuDevice.createBuffer({ size: gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
        const bufferB1 = gpuDevice.createBuffer({ size: gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
        const bufferB2 = gpuDevice.createBuffer({ size: gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
        const uniformBuffer = gpuDevice.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        const counterBuffer = gpuDevice.createBuffer({ size: 8, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
        const hammingBuffer = gpuDevice.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
        const readBuffer = gpuDevice.createBuffer({ size: 4, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });

        gpuDevice.queue.writeBuffer(bufferA1, 0, gridA);
        gpuDevice.queue.writeBuffer(bufferB1, 0, gridB);

        const workgroups = Math.ceil(size / 16);

        // Run both simulations
        let curA = 0, curB = 0;
        for (let step = 0; step < steps; step++) {
          gpuDevice.queue.writeBuffer(counterBuffer, 0, new Uint32Array([0, 0]));
          gpuDevice.queue.writeBuffer(uniformBuffer, 0, new Uint32Array([size, birthMask, survivalMask, step]));

          const encoder = gpuDevice.createCommandEncoder();

          // Step grid A
          const bindGroupA = gpuDevice.createBindGroup({
            layout: caPipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: uniformBuffer } },
              { binding: 1, resource: { buffer: curA === 0 ? bufferA1 : bufferA2 } },
              { binding: 2, resource: { buffer: curA === 0 ? bufferA2 : bufferA1 } },
              { binding: 3, resource: { buffer: counterBuffer } },
            ],
          });
          const passA = encoder.beginComputePass();
          passA.setPipeline(caPipeline);
          passA.setBindGroup(0, bindGroupA);
          passA.dispatchWorkgroups(workgroups, workgroups);
          passA.end();

          // Step grid B
          gpuDevice.queue.writeBuffer(counterBuffer, 0, new Uint32Array([0, 0]));
          const bindGroupB = gpuDevice.createBindGroup({
            layout: caPipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: uniformBuffer } },
              { binding: 1, resource: { buffer: curB === 0 ? bufferB1 : bufferB2 } },
              { binding: 2, resource: { buffer: curB === 0 ? bufferB2 : bufferB1 } },
              { binding: 3, resource: { buffer: counterBuffer } },
            ],
          });
          const passB = encoder.beginComputePass();
          passB.setPipeline(caPipeline);
          passB.setBindGroup(0, bindGroupB);
          passB.dispatchWorkgroups(workgroups, workgroups);
          passB.end();

          gpuDevice.queue.submit([encoder.finish()]);
          curA = 1 - curA;
          curB = 1 - curB;
        }

        // Compute hamming distance
        gpuDevice.queue.writeBuffer(hammingBuffer, 0, new Uint32Array([0]));
        const hammingBindGroup = gpuDevice.createBindGroup({
          layout: hammingPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: curA === 0 ? bufferA1 : bufferA2 } },
            { binding: 1, resource: { buffer: curB === 0 ? bufferB1 : bufferB2 } },
            { binding: 2, resource: { buffer: hammingBuffer } },
          ],
        });

        const hammingEncoder = gpuDevice.createCommandEncoder();
        const hammingPass = hammingEncoder.beginComputePass();
        hammingPass.setPipeline(hammingPipeline);
        hammingPass.setBindGroup(0, hammingBindGroup);
        hammingPass.dispatchWorkgroups(Math.ceil(size * size / 256));
        hammingPass.end();
        hammingEncoder.copyBufferToBuffer(hammingBuffer, 0, readBuffer, 0, 4);
        gpuDevice.queue.submit([hammingEncoder.finish()]);

        await readBuffer.mapAsync(GPUMapMode.READ);
        const distance = new Uint32Array(readBuffer.getMappedRange())[0];
        readBuffer.unmap();

        const lambda = distance === 0 ? -10 : Math.log(distance) / steps;
        lambdas.push(lambda);

        // Cleanup
        bufferA1.destroy(); bufferA2.destroy();
        bufferB1.destroy(); bufferB2.destroy();
        uniformBuffer.destroy(); counterBuffer.destroy();
        hammingBuffer.destroy(); readBuffer.destroy();
      }

      const valid = lambdas.filter(l => l > -10);
      if (valid.length === 0) return { mean: -10, std: 0 };
      const mean = valid.reduce((a, b) => a + b, 0) / valid.length;
      const std = Math.sqrt(valid.reduce((s, l) => s + (l - mean) ** 2, 0) / valid.length);
      return { mean, std };
    }

    async function measureAutocorrGPU(gridBuffer, size, population) {
      if (population === 0) return 0;

      const autocorrUniform = gpuDevice.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
      const autocorrCounter = gpuDevice.createBuffer({ size: 8, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
      const readBuffer = gpuDevice.createBuffer({ size: 8, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });

      gpuDevice.queue.writeBuffer(autocorrUniform, 0, new Uint32Array([size, population, 0, 0]));
      gpuDevice.queue.writeBuffer(autocorrCounter, 0, new Int32Array([0, 0]));

      const bindGroup = gpuDevice.createBindGroup({
        layout: autocorrPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: autocorrUniform } },
          { binding: 1, resource: { buffer: gridBuffer } },
          { binding: 2, resource: { buffer: autocorrCounter } },
        ],
      });

      const encoder = gpuDevice.createCommandEncoder();
      const pass = encoder.beginComputePass();
      pass.setPipeline(autocorrPipeline);
      pass.setBindGroup(0, bindGroup);
      pass.dispatchWorkgroups(Math.ceil(size / 16), Math.ceil(size / 16));
      pass.end();
      encoder.copyBufferToBuffer(autocorrCounter, 0, readBuffer, 0, 8);
      gpuDevice.queue.submit([encoder.finish()]);

      await readBuffer.mapAsync(GPUMapMode.READ);
      const data = new Int32Array(readBuffer.getMappedRange());
      const sum = data[0];
      const count = data[1];
      readBuffer.unmap();

      autocorrUniform.destroy();
      autocorrCounter.destroy();
      readBuffer.destroy();

      // Normalize
      const mean = population / (size * size);
      const variance = mean * (1 - mean);
      return variance > 0 ? sum / (count * variance * size * size) : 0;
    }

    function measureSymmetry(grid, size) {
      let matchH = 0, matchV = 0, totalH = 0, totalV = 0;
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size / 2; c++) {
          const v1 = grid[r * size + c] > 0;
          const v2 = grid[r * size + (size - 1 - c)] > 0;
          if (v1 === v2) matchH++;
          totalH++;
        }
      }
      for (let r = 0; r < size / 2; r++) {
        for (let c = 0; c < size; c++) {
          const v1 = grid[r * size + c] > 0;
          const v2 = grid[(size - 1 - r) * size + c] > 0;
          if (v1 === v2) matchV++;
          totalV++;
        }
      }
      return { h: totalH > 0 ? matchH / totalH : 0, v: totalV > 0 ? matchV / totalV : 0 };
    }

    function downsampleGrid(grid, srcSize, dstSize) {
      const result = new Uint8Array(dstSize * dstSize);
      const scale = srcSize / dstSize;
      for (let r = 0; r < dstSize; r++) {
        for (let c = 0; c < dstSize; c++) {
          let sum = 0;
          const r0 = Math.floor(r * scale);
          const c0 = Math.floor(c * scale);
          for (let dr = 0; dr < scale; dr++) {
            for (let dc = 0; dc < scale; dc++) {
              if (grid[(r0 + dr) * srcSize + (c0 + dc)] > 0) sum++;
            }
          }
          result[r * dstSize + c] = sum > scale * scale / 2 ? 1 : 0;
        }
      }
      return result;
    }

    function ruleIdToString(id) {
      const birthMask = Math.floor(id / 512);
      const survivalMask = id % 512;
      let b = '', s = '';
      for (let i = 0; i <= 8; i++) {
        if (birthMask & (1 << i)) b += i;
        if (survivalMask & (1 << i)) s += i;
      }
      return `B${b}/S${s}`;
    }

    // ============================================
    // UI FUNCTIONS
    // ============================================
    function parseCSV(text) {
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].match(/(".*?"|[^,]+)/g) || [];
        const row = {};
        headers.forEach((h, j) => {
          let v = (values[j] || '').replace(/^"|"$/g, '').trim();
          row[h] = isNaN(v) || v === '' ? v : parseFloat(v);
        });
        data.push(row);
      }
      return data;
    }

    function loadFromLocalStorage() {
      try {
        const data = JSON.parse(localStorage.getItem('cells_survey_gpu'));
        if (data && data.results) {
          pass1Data = data.results;
          log(`Loaded ${pass1Data.length} rules from localStorage`, 'success');
          document.getElementById('load-status').textContent = `Loaded ${pass1Data.length} rules`;
          applyFilter();
        } else {
          log('No GPU survey data in localStorage', 'error');
        }
      } catch (e) {
        log('Failed to load: ' + e.message, 'error');
      }
    }

    function applyFilter() {
      const classFilter = document.getElementById('filter-class').value;
      const lambdaMax = parseFloat(document.getElementById('filter-lambda-max').value);
      const popMin = parseInt(document.getElementById('filter-pop-min').value);
      const noB0 = document.getElementById('filter-no-b0').checked;

      filteredData = pass1Data.filter(r => {
        if (classFilter !== 'all' && r.classification !== classFilter) return false;
        if (r.lambda > lambdaMax && r.lambda > -10) return false;
        if ((r.pop_final || 0) < popMin) return false;
        if (noB0 && r.has_B0) return false;
        return true;
      });

      document.getElementById('filter-count').textContent = `${filteredData.length} rules match`;
      document.getElementById('btn-run-pass2').disabled = filteredData.length === 0 || !gpuAvailable;
      renderTable();
      log(`Filter: ${filteredData.length} rules match`, 'info');
    }

    function renderTable() {
      const tbody = document.getElementById('results-body');
      if (filteredData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;color:#444">No matching rules</td></tr>';
        return;
      }

      tbody.innerHTML = filteredData.slice(0, 500).map(r => `
        <tr data-rule-id="${r.rule_id}" class="${r.rule_id === selectedRuleId ? 'selected' : ''}">
          <td>${r.rule_id}</td>
          <td>${r.rule_string}</td>
          <td>${r.lambda > -10 ? r.lambda.toFixed(4) : '--'}</td>
          <td>${(r.D || 0).toFixed(2)}</td>
          <td>${r.period || '--'}</td>
          <td>${(r.pop_final || 0).toLocaleString()}</td>
          <td>${r.classification || '--'}</td>
        </tr>
      `).join('');

      tbody.querySelectorAll('tr').forEach(row => {
        row.addEventListener('click', () => selectRule(parseInt(row.dataset.ruleId)));
      });
    }

    async function selectRule(ruleId) {
      selectedRuleId = ruleId;
      renderTable();

      const rule = pass1Data.find(r => r.rule_id === ruleId);
      if (!rule) return;

      document.getElementById('selected-rule-name').textContent = rule.rule_string;

      // Pass 1 metrics
      document.getElementById('pass1-metrics').innerHTML = `
        <div class="metric-item"><div class="metric-label">λ</div><div class="metric-value">${rule.lambda > -10 ? rule.lambda.toFixed(4) : '--'}</div></div>
        <div class="metric-item"><div class="metric-label">D</div><div class="metric-value">${(rule.D || 0).toFixed(3)}</div></div>
        <div class="metric-item"><div class="metric-label">Period</div><div class="metric-value">${rule.period || '--'}</div></div>
        <div class="metric-item"><div class="metric-label">Pop</div><div class="metric-value">${(rule.pop_final || 0).toLocaleString()}</div></div>
      `;

      // Check for existing Pass 2 data
      if (pass2Results.has(ruleId)) {
        displayPass2Results(pass2Results.get(ruleId));
      } else if (gpuAvailable) {
        log(`Running analysis for ${rule.rule_string}...`, 'info');
        clearPass2Display();
        const result = await runGPUAnalysis(ruleId);
        pass2Results.set(ruleId, result);
        displayPass2Results(result);
        log(`Analysis complete for ${rule.rule_string}`, 'success');
      }
    }

    function clearPass2Display() {
      document.getElementById('m-lambda10').textContent = '...';
      document.getElementById('m-lambda10-std').textContent = '...';
      document.getElementById('m-autocorr').textContent = '...';
      document.getElementById('m-symmetry').textContent = '...';
      ['preview-t100', 'preview-t500', 'preview-t1000', 'preview-final'].forEach(id => {
        const ctx = document.getElementById(id).getContext('2d');
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, 64, 64);
      });
    }

    function displayPass2Results(r) {
      document.getElementById('m-lambda10').textContent = r.lambda_10 > -10 ? r.lambda_10.toFixed(4) : 'healed';
      document.getElementById('m-lambda10-std').textContent = r.lambda_10_std.toFixed(4);
      document.getElementById('m-autocorr').textContent = r.spatial_autocorr.toFixed(4);
      document.getElementById('m-symmetry').textContent = `H:${(r.symmetry_h * 100).toFixed(0)}% V:${(r.symmetry_v * 100).toFixed(0)}%`;

      // Draw snapshots
      drawSnapshot('preview-t100', r.snapshots.t100);
      drawSnapshot('preview-t500', r.snapshots.t500);
      drawSnapshot('preview-t1000', r.snapshots.t1000);
      drawSnapshot('preview-final', r.snapshots[`t${r.pop_trajectory[r.pop_trajectory.length - 1]?.t || 2000}`] || r.snapshots.t2000);

      // Draw charts
      drawPopChart(r.pop_trajectory);
      drawActivityChart(r.activity_trajectory);
    }

    function drawSnapshot(canvasId, data) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#050505';
      ctx.fillRect(0, 0, 64, 64);
      if (!data) return;

      const size = Math.sqrt(data.length);
      ctx.fillStyle = '#4a7a4a';
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (data[r * size + c] > 0) {
            ctx.fillRect(c, r, 1, 1);
          }
        }
      }
    }

    function drawPopChart(trajectory) {
      const canvas = document.getElementById('pop-chart');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.parentElement.clientWidth;
      const h = canvas.height = 80;

      ctx.fillStyle = '#0d0d0d';
      ctx.fillRect(0, 0, w, h);
      if (!trajectory || trajectory.length < 2) return;

      const maxPop = Math.max(...trajectory.map(p => p.pop)) || 1;
      ctx.strokeStyle = '#4a7a4a';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      trajectory.forEach((p, i) => {
        const x = (i / (trajectory.length - 1)) * (w - 10) + 5;
        const y = h - 5 - (p.pop / maxPop) * (h - 10);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    function drawActivityChart(trajectory) {
      const canvas = document.getElementById('activity-chart');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.parentElement.clientWidth;
      const h = canvas.height = 80;

      ctx.fillStyle = '#0d0d0d';
      ctx.fillRect(0, 0, w, h);
      if (!trajectory || trajectory.length < 2) return;

      const maxAct = Math.max(...trajectory.map(p => p.activity)) || 1;
      ctx.strokeStyle = '#7a7a4a';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      trajectory.forEach((p, i) => {
        const x = (i / (trajectory.length - 1)) * (w - 10) + 5;
        const y = h - 5 - (p.activity / maxAct) * (h - 10);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    async function runPass2() {
      isRunning = true;
      document.getElementById('btn-run-pass2').disabled = true;
      document.getElementById('btn-stop').disabled = false;

      const total = filteredData.length;
      let completed = 0;

      for (const rule of filteredData) {
        if (!isRunning) break;
        if (pass2Results.has(rule.rule_id)) {
          completed++;
          continue;
        }

        try {
          const result = await runGPUAnalysis(rule.rule_id);
          pass2Results.set(rule.rule_id, result);
        } catch (e) {
          log(`Error on ${rule.rule_string}: ${e.message}`, 'error');
        }

        completed++;
        document.getElementById('progress-fill').style.width = `${(completed / total) * 100}%`;
        document.getElementById('progress-text').textContent = `${completed} / ${total}`;

        if (completed % 10 === 0) {
          log(`Pass 2: ${completed}/${total}`, 'info');
        }
      }

      isRunning = false;
      document.getElementById('btn-run-pass2').disabled = false;
      document.getElementById('btn-stop').disabled = true;
      document.getElementById('btn-download').disabled = pass2Results.size === 0;
      log(`Pass 2 complete: ${pass2Results.size} rules`, 'success');
    }

    function exportCSV() {
      const headers = ['rule_id', 'rule_string', 'lambda_10', 'lambda_10_std', 'spatial_autocorr', 'symmetry_h', 'symmetry_v'];
      const rows = [headers.join(',')];
      for (const [id, r] of pass2Results) {
        rows.push([
          r.rule_id, `"${r.rule_string}"`,
          r.lambda_10.toFixed(6), r.lambda_10_std.toFixed(6),
          r.spatial_autocorr.toFixed(6), r.symmetry_h.toFixed(4), r.symmetry_v.toFixed(4)
        ].join(','));
      }
      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `pass2-${new Date().toISOString().slice(0, 10)}.csv`;
      a.click();
    }

    // ============================================
    // EVENT HANDLERS
    // ============================================
    document.getElementById('file-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        pass1Data = parseCSV(ev.target.result);
        log(`Loaded ${pass1Data.length} rules from CSV`, 'success');
        document.getElementById('load-status').textContent = `Loaded ${pass1Data.length} rules`;
        applyFilter();
      };
      reader.readAsText(file);
    });

    document.getElementById('btn-load-localstorage').addEventListener('click', loadFromLocalStorage);
    document.getElementById('btn-apply-filter').addEventListener('click', applyFilter);
    document.getElementById('btn-run-pass2').addEventListener('click', runPass2);
    document.getElementById('btn-stop').addEventListener('click', () => { isRunning = false; });
    document.getElementById('btn-download').addEventListener('click', exportCSV);

    // Table sorting
    document.querySelectorAll('.results-table th[data-sort]').forEach(th => {
      th.addEventListener('click', () => {
        const key = th.dataset.sort;
        filteredData.sort((a, b) => {
          const va = a[key] ?? -Infinity;
          const vb = b[key] ?? -Infinity;
          return va > vb ? -1 : 1;
        });
        renderTable();
      });
    });

    // Initialize
    initWebGPU();
    log('Pass 2 analyzer ready', 'success');
  </script>
</body>
</html>
